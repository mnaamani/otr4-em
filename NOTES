why call to fragment_and_send() in otrl_message_sending passing NULL instead of the opdata pointer?

solution 1:

libotr-4.0.0/src/message.c - otrl_message_sending()
----------------------------------
fragment:
    if (fragPolicy == OTRL_FRAGMENT_SEND_SKIP ) {
    /* Do not fragment/inject. Default behaviour of libotr3.2.0 */
    return err;
    } else {
    /* Fragment and send according to policy */
    if (!err && messagep && *messagep) {
        if (context) {
        /*err = fragment_and_send(ops, NULL, context, *messagep, fragPolicy, messagep);*/// line 444
        err = fragment_and_send(ops, opdata, context, *messagep, fragPolicy, messagep);        
        }
    }
    return err;
    }

solution 2:
    dont fragment,
    pass in OTRL_FRAGMENT_SEND_SKIP as fragPolicy to otrl_message_sending()
    handle sending ourself.
